# -*- coding: utf-8 -*-
"""
Created on Mon Sep 12 20:15:44 2022

@author: arman hossain
"""

from PyQt5.QtWidgets import (
    QWidget)
from PyQt5.uic import loadUi



class Info_widget(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        loadUi("info.ui", self) # this ui file is a widget so it can be placed within qmainwindow
        # qdialog cannot be load on qmainwindow file
        self.setWindowTitle("Detail View")
        self.maping = {
        'AV':{
            'N':'NETWORK',
            'A':'ADJACENT_NETWORK',
            'L':'LOCAL',
            'P':'PHYSICAL'
            },
        'AC':{
            'L':'LOW',
            'H':'HIGH'
            },
        'PR':{
            'N':'NONE',
            'L':'LOW',
            'H':'HIGH'
            },
        'UI':{
            'N':'NONE',
            'R':'REQUIRED'
            },
        'C':{
            'N':'NONE',
            'H':'HIGH',
            'L':'LOW'
            },
        'I':{
            'N':'NONE',
            'H':'HIGH',
            'L':'LOW'
            },
        'A':{
            'N':'NONE',
            'H':'HIGH',
            'L':'LOW'
            },
        'S':{
            'C':'CHANGED',
            'U':'UNCHANGED'
            }
        }

        self.met_value_mapping ={
            'attackVector':{
                'NETWORK': 0.85,
                'ADJACENT_NETWORK': 0.62,
                'LOCAL': 0.55,
                'PHYSICAL': 0.2
                },
            'attackComplexity':{
                'LOW': 0.77,
                'HIGH': 0.44
                },
            'privilegesRequired':{
                'NONEUNCHANGED': 0.85,
                'NONECHANGED': 0.85,
                'LOWUNCHANGED': 0.62,
                'LOWCHANGED': 0.68,
                'HIGHUNCHANGED': 0.27,
                'HIGHCHANGED': 0.5
                },
            'userInteraction':{
                'NONE': 0.85,
                'REQUIRED': 0.62
                },
            'confidentialityImpact':{
                'NONE': 0,
                'HIGH': 0.56,
                'LOW': 0.22
                },
            'integrityImpact':{
                'NONE': 0,
                'HIGH': 0.56,
                'LOW': 0.22
                },
            'availabilityImpact':{
                'NONE': 0,
                'HIGH': 0.56,
                'LOW': 0.22
                },
            }
    
    def ven_prod(self,item):
        # item = data.cpeUri
        if(not isinstance(item, str)):
            return ("","")
        cpe_lst = item.split('#arman#')
        vendors = []
        prods = []
        for a_cpe in cpe_lst:
            a_cpe_sp = a_cpe.split(':')
            vendor= a_cpe_sp[3]
            prod = vendor+"_"+a_cpe_sp[4]
            if vendor not in vendors:
                vendors.append(vendor)
            
            if prod not in prods:
                prods.append(prod)
        return (", ".join(vendors),", ".join(prods))
    
    def find_max(self,dictonary,desc):
        # dictonary = {'adf':['sdfsd','sdf'],'gg':['dfs']} 
        key = list(dictonary.keys())[0]
        max_cnt = 0
        for k in dictonary:
            cnt = 0
            for item in dictonary[k]:
                if desc.find(item)>-1:
                    cnt+=1
            if cnt/len(dictonary[k])>max_cnt:
                max_cnt = cnt/len(dictonary[k])
                key = k
        return k
    
    def roundup(self,val):
        if val == int(val): return val
        return float(('{0:.1f}'. format((val+0.05))))
    def onedec(self,val):
        return float(('{0:.1f}'. format((val))))
    
    def cvss_rank(self,base_score):
        if base_score < 0.1:
            return 'NONE'
        elif base_score < 4.0:
            return 'LOW'
        elif base_score < 7.0:
            return 'MEDIUM'
        elif base_score < 9.0:
            return 'HIGH'
        else:
            return 'CRITICAL'
    
    def base_score(self,ac,av,pr,ui,ci,ii,ai,scope):
        exploitabilityScore = 0
        impactScore = 0
        baseScore = 0
        ISS = 1 - ( (1 - self.met_value_mapping['confidentialityImpact'][ci]) * (1 - self.met_value_mapping['integrityImpact'][ii]) * (1 - self.met_value_mapping['availabilityImpact'][ai]) )
        if scope == 'CHANGED':    
            impactScore = 7.52 * (ISS - 0.029) - 3.25 * (ISS - 0.02) ** 15
        else:
            impactScore = ISS * 6.42
        
        exploitabilityScore = 8.22 * self.met_value_mapping['attackVector'][av] * self.met_value_mapping['attackComplexity'][ac] * self.met_value_mapping['privilegesRequired'][pr+scope] * self.met_value_mapping['userInteraction'][ui]
        
        if impactScore <= 0:
            baseScore = 0 
        elif scope == 'CHANGED':
            baseScore = self.roundup(min (1.08 * (impactScore + exploitabilityScore), 10))
        else:
            baseScore = self.roundup(min((impactScore + exploitabilityScore), 10))
        
        
        return baseScore


    def cvss_calc(self,desc):
        # desc = 'Buffer overflow in NFS mountd gives root access to remote attackers, mostly in Linux systems.'
        dictonary = {'NETWORK': ['remote', 'xss', 'php', 'web', 'network', 'http', 'script', 'file', 'ur', 'site', 'network access', 'site script', 'with network', 'google chrome', 'remote attacker'],
                'ADJACENT_NETWORK':['adjacent', 'attacker', 'cisco', 'network', 'via', 'route', 'same', 'access', 'intel', 'allows','adjacent attacker', 'via adjacent', 'same network', 'adjacent access','adjacent attackers'],
                'LOCAL':['local', 'privilege', 'windows', 'privileges', 'file', 'kernel', 'elevation', 'remote', 'access', 'attacker','local attacker', 'local access', 'local users', 'local information','infrastructure where'],
                'PHYSICAL':['physical', 'access', 'usb', 'device', 'allows', 'physically', 'intel', 'attacker', 'via','lock','physical access', 'via physical', 'usb device', 'allows physical','allows physically','malicious usb']
                }
        av = self.find_max(dictonary,desc)
        dictonary = {'LOW': ['xss', 'file', 'crafted', 'web', 'user', 'site', 'needed', 'server', 'easily', 'exploit' ,'easily exploit','easily', 'user interaction', 'site script', 'successful exploitation'],
                'HIGH':['engine', 'difficult', 'exploit', 'vulnerability', 'script', 'to', 'race', 'middle', 'man','memory','difficult to', 'to exploit', 'race condition', 'difficult', 'exploit vulnerability']
                }
        ac = self.find_max(dictonary,desc)
        dictonary = {'HIGH': ['privileged', 'high', 'allows', 'attacker', 'admin', 'user', 'authentic', 'administrator','privileges', 'oracle','high privileged', 'privileged attacker', 'allows high', 'privileged user','system execution'],
                'LOW':['authenticated', 'local', 'user', 'users', 'allows', 'attacker', 'low', 'elevation','privileged', 'privilege', 'low privileged', 'allows low', 'local users', 'authenticated user', 'allows local'],
                'NONE':['unauthenticated', 'remote', 'attackers', 'attacker', 'exploitation', 'code','corruption', 'vulnerability', 'network', 'successful','remote attackers', 'successful exploitation', 'unauthenticated attacker','remote code', 'remote attacker']
                }
        
        pr = self.find_max(dictonary,desc)
        dictonary = {'REQUIRED': ['xss', 'site', 'script', 'cross', 'crafted', 'malicious', 'interaction', 'file', 'csrf', 'php', 'site script', 'human interaction', 'crafted html', 'html page', 'xss via'],
                'NONE':['local', 'network', 'user', 'server', 'oracle', 'sql', 'allows', 'devices', 'php','injection','sql injection', 'not needed', 'contract implementation', 'linux kernel','network access']
                }
        ui = self.find_max(dictonary,desc)
        dictonary = {'HIGH': ['code', 'execution', 'arbitrary', 'execute', 'disclosure', 'privilege', 'privileges','injection', 'information', 'bounds','code execution', 'arbitrary code', 'execute arbitrary', 'remote code','information disclosure'],
                'LOW':['xss', 'script', 'arbitrary', 'html', 'site', 'stored', 'unauthorized', 'allows', 'web','code' 'site script', 'stored xss', 'unauthorized read', 'allows xss', 'read access'],
                'NONE':['denial', 'service', 'contract', 'cause', 'dos', 'crash', 'result', 'balance', 'set','function','frequently repeat', 'complete dos', 'contract implementation', 'null pointer','service attack']
                }
        ci = self.find_max(dictonary,desc)
        dictonary = {'HIGH': ['code', 'execution', 'arbitrary', 'execute', 'privilege', 'injection', 'privileges','remote', 'vulnerability', 'sql','code execution', 'arbitrary code', 'execute arbitrary', 'remote code','sql injection'],
                'LOW':['xss', 'script', 'site', 'html', 'insert', 'update', 'unauthorized', 'php', 'stored', 'result' 'site script', 'unauthorized update', 'stored xss', 'update', 'insert'],
                'NONE':['denial', 'disclosure', 'information', 'read', 'service', 'crash', 'vulnerability', 'dos','sensitive', 'and','information disclosure', 'sensitive information', 'read vulnerability','disclosure vulnerability', 'bounds read']
                }
        ii = self.find_max(dictonary,desc)
        dictonary = {'HIGH': ['code', 'service', 'execution', 'denial', 'execute', 'arbitrary', 'buffer', 'crash', 'of','privilege','code execution', 'arbitrary code', 'denial of', 'of service','execute arbitrary', 'buffer over'],
                'LOW':['partial', 'cause', 'denial', 'service', 'dos', 'consume', 'entity', 'processing', 'restart','injection','partial denial', 'entity injection', 'undefined behavior', 'temporarily unavailable','consume'],
                'NONE':['xss', 'disclosure', 'information', 'script', 'site', 'read', 'data', 'accessible', 'files','arbitrary','site script', 'information disclosure', 'accessible data', 'stored xss','sensitive information']
                }
        ai = self.find_max(dictonary,desc)
        dictonary = {'CHANGED': ['xss', 'script', 'site', 'cross', 'impact', 'products', 'attacks', 'stored', 'may', 'has', 'site script', 'xss via', 'attacks may', 'stored xss', 'has xss'],
                'UNCHANGED':['code', 'memory', 'execution', 'information', 'buffer', 'function', 'can', 'denial','sql', 'password','code execution', 'can result', 'information disclosure', 'arbitrary code','sql injection']
                }
        scope = self.find_max(dictonary,desc)
        
        
        
        baseScore = self.base_score(ac,av,pr,ui,ci,ii,ai,scope)
        
        return ac,av,pr,ui,ci,ii,ai,scope,self.cvss_rank(baseScore)
        
        
    def setdata(self,data):
        # print(data)
        # CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H
        if type(data.vectorString_v31) != float:
            met = data.vectorString_v31.split("/")
            # print(met)
            self.ac.setText(self.maping[met[2].split(":")[0]][met[2].split(":")[1]])
            
            self.au.setText(self.maping[met[4].split(":")[0]][met[4].split(":")[1]]) #UI
            self.av.setText(self.maping[met[1].split(":")[0]][met[1].split(":")[1]]) 
            self.pr.setText(self.maping[met[3].split(":")[0]][met[3].split(":")[1]])
            self.scope.setText(self.maping[met[5].split(":")[0]][met[5].split(":")[1]])
            
            self.ci.setText(self.maping[met[6].split(":")[0]][met[6].split(":")[1]])
            self.ii.setText(self.maping[met[7].split(":")[0]][met[7].split(":")[1]])
            self.ai.setText(self.maping[met[8].split(":")[0]][met[8].split(":")[1]])
            
            cvss_rank = self.cvss_rank(data.CVSS_v31)
            self.cvss_rating.setText(cvss_rank)
        else:
            ac,av,pr,ui,ci,ii,ai,scope,cvss_rank = self.cvss_calc(data.description)
            self.cvss_rating.setText(cvss_rank+'*')
            self.ac.setText(ac+'*')
            
            self.au.setText(ui+'*') #UI
            self.av.setText(av+'*') 
            self.pr.setText(pr+'*')
            self.scope.setText(scope+'*')
            
            self.ci.setText(ci+'*')
            self.ii.setText(ii+'*')
            self.ai.setText(ai+'*')
            
        self.id.setText(str(data.ID))
        
        vend,prod = self.ven_prod(data.cpeUri)
        
        self.vendors.setText(vend)
        self.products.setText(prod)
        
        self.date.setText(str(data.publishedDate))
        if type(data.tags) != float:
            self.tags.setText(", ".join(data.tags.split("#arman#")))
        self.codelinks.setText(str(data.code_link))
        # self.codelinks.setText('https://exploit-db.com/exploits/54')
        if type(data.url) != float:
            self.ref_links.setText(", ".join(data.url.split("#arman#")))
        # self.ref_source.setText(str(data.))
        
        self.desc.setText(data.description)
        
        self.barchart_frame.update_chart([data.CVSS_v2,data.CVSS_v31,data.epss])
        
        
       